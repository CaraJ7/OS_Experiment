## Lab 7 Guidance

这个实验应该是所有实验里面最简单的一个了，代码量很小，而且也都不难。只要熟悉概念很快就可以做出来。

### Uthread: switching between threads

这个东西要不要考虑锁？因为他是多个线程，并且确实在每个线程里面访问了一些多个线程共享的变量。

答案是不用。首先他是一个进程，所以不存在进程之间冲突的问题，而且一个进程在某一个时刻确实只是在一个CPU上运行的。那么线程呢？线程冲不冲突？答案是也不会。因为考虑到的线程的时间片到期以后切换的情况，其实是线程的底层的实现了，我们并不知道何时时间片会到期，所以要在共享变量上加一把锁。但此时完全是我们控制的什么时候schedule，不存在共享变量被冲突访问的问题。

另外，yield和schedule的区别在于，yield是当前线程放弃了CPU，但是它还会回来（state=runnable)，但是schedule不是，一个线程如果直接调用了schedule，他就再也回不来了，因为他的state是running，schedule不会选择running的进程执行。这也就解释了其实最后退出一定是在schedule里面的exit退出而不是main的exit。

在`thread_create`函数中，栈的sp指针应该放在栈顶，也就是`stack+STACKSIZE`，因为这个时候是在创建进程，栈还没有被使用，并且栈是从上向下增长的，所以应该放到内存的最大值。而ra指针直接指向初始化传入的参数的地址就可以了。

### Using threads

这个写过了lock以后就非常简单了，就是多个线程没有互斥地向桶内放元素，导致放入的值丢失了。解决方法就是给每个哈希桶加一把锁，每当访问的时候就锁上桶，访问结束以后再把锁放开。

具体来看，每个线程都执行的是`put_thread`函数，传入的参数是线程的编号，在`put_thread`函数中执行的是`put`函数，并且每个线程只放自己的那一部分，这是通过线程的编号来区分的，这个线程的编号类似二维数组的第一维。

这个写函数做的事情是根据keys数组中的给定值，通过哈希函数找到这个值对应的桶，然后把keys数组中的这个值用头插法插入这个桶当中（桶是一个单向链表），同时，这个桶内的元素其实是一个结构体，不只有keys数组中的这个值，还记录了这是哪一个线程插入的。如果keys数组的这个值已经在桶内存在（完全有可能出现，因为keys数组是随机初始化的）,那么就把这个结构体中记录是哪一个线程插入的记录更新为当前进程。如果不给每个桶加锁，大概率是会有多个线程之间彼此共同访问一个桶，并且在插入的时候造成丢失。

读的函数(get)就是用keys中的每一个值，都到它对应的哈希桶内去寻找，如果线程之间没有发生冲突的话，应该是可以找到每一个keys的。

### Barrier

这个所谓barrier就是一种进程同步的方式，`pthread_join`是在结束的时候同步，那么barrier其实是在运行的过程中同步，这个实验也比较简单。

只需要更改barrier函数就可以了。由于每个线程都要访问bstate变量，所以每次访问之前要加上锁，进入临界区以后，将`bstate.nthread++`，说明又一个线程执行到了这个位置。然后查看是不是所有线程都到达了，如果还没有，那么调用`pthread_cond_wait`函数，这个函数会让当前线程sleep，同时放开临界区的锁，这样下一个执行到这里的进程也可以进入临界区，标记又一个线程的到达；如果所有线程都到达了，把到达线程的数目清空，标记`bstate.round++`，同时调用`pthread_cond_broadcast`通知所有线程可以继续运行了。此时所有线程会去竞争临界区的锁，然后再向下执行（尽管拿到锁以后下一句指令就是放开锁。。）
