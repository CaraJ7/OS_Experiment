## A Guidance to Lab5

### 1.Eliminate allocation from sbrk()

我找了半天到底为什么会调用`sys_sbrk()`，原来是`sh.c`里面的`parse_cmd`里面用到了`malloc`函数，而`malloc`函数就是主要的在用户态调用`sbrk`的函数。调用了这个给子进程（相对于`sh`），子进程在运行的时候访问了没有分配的虚拟内存，导致出现`usertrap`进入内核，内核直接`exit`了子进程，再由于`exit`函数的注释，父进程在`wait`的时候将子进程杀掉，但是杀掉的时候有一步`freeproc`会调用`uvmunmap`，这个函数是根据进程的`sz`来的，由于`sz`中有没有被实际分配物理地址的，所以会产生`uvmunmap`错误。

### 2.Lazy allocation

这个比较简单，就是基本的处理，因为上一步我们只是骗用户进程，告诉你，好，我给你的内存容量变大了，但实际上并不是这样，用户的页表里面的映射一点都没有变，所以用户在使用他以为新得到的空间的时候，页表找不到对应的物理地址，出错，进入usertrap()。那么我们就要在这里去处理这个问题。首先判断usertrap的原因，`r_scause`有三种情况的值对应page fault错误（实验指导里面只提到了2种，13和15，但事实上还有12，只不过12这个page fault是取不到指令，这是在copy-on-write用到的，这里如果是12这种错误，还是有错的）

开始讲处理方法。检测`r_scause`为13或15的时候，进入`lazy_compensation`函数，检测到底这个page fault是不是由lazy allocation导致的（不能导致的原因包括：访问的va大于进程的sz，va是栈的保护页，va大于MAXVA），如果不是，那么我们就要给他需要用的那一页加一个page，即用`uvmalloc`在对应的位置加一个页。这就做完了。非常简单，已经可以正常运行echo hi了。

还有一些小地方需要加一加，比如`uvmunmap`的时候其实是按照页表一个一个页读的，如果有一些没有用到的页，也即没有实际分配地址的页，那么如果不改就会unmap，因为`uvmunmap`是要求mapping必须存在的。

### 3.Lazytests and Usertests

为了写实验报告，写一写各个提示对应的解决措施。

+ 处理负数情况的sbrk。

  仍然使用growproc,负数的时候是调用的`uvmdealloc`，最后用的还是`uvmunmap`，这个上一步已经改好了

+ 第二个需求上一个里面就考虑了

+ fork的时候要从parent到child合理

  这个是在`uvmcopy`的时候，即使父进程在页表里面找不到对应的页，也不要panic,直接往下走就完事了

+ 如果是传进来一个指针，要用那里面的地址

  这个就是下面那一大段讲的事情

+ 这个处理没有空间,`kalloc`失败的时候杀掉进程，上一个也已经考虑了

+ 这个也考虑完了，就在上面的一个判断就完事了

这里我们认为，如果真的传进来了地址，这个地址只能是从用户态拷贝到内核或者从内核拷贝到用户态，也即`copyin,copyinstr,copyout`三个函数,并且认为只要需要用到用户态的虚拟地址，一定是从这三个函数用，不会自己私自去检查。

实现的方法就是在这三个函数里面，当用到地址之前，先看它是不是Lazy allocation导致的，定义了一个`lazy_isunmap`函数，是用来检验这个va是不是被map过，因为`lazy_compensate`直接就分配了，因为他是在usertrap里面用到的，已经确定了是没有被map的地址，所以要先试用`lazy_isunmap`判断一下，如果已经被map了，就是正常情况，直接使用三个函数就可以了。

有两个问题没解决，

一个是`usertests/sbrkarg`，在`lazy_isunmap`里面对`if`的第三个的设置，我不理解为什么要判断页表项是否有效，正常来说只要这个页表项不对应物理地址，就应该已经是0了。

第二个是`lazytests/outofmemory`，在测试中进入这个函数的时候，进程的`sz`已经远远大于`MAXVA`了，所以我不得不加了第一个`if`让他`break`掉。**md老子服了，sys_sbrk的时候用的是一个int来接收一个uint64`sz`，那nm能不超`MAXVA`吗，高位直接`ffff`了好的吧，改一下`sys_sbrk`，用uint64去接`sz`，这样就不需要前面的那个if了**，但是时间也要稍微长一点，因为这个是真的没空间了才返回的 