## A Guidance to Exp2

### 1. Trace

​	系统调用的时候，是从用户态切换到内核态。这个时候需要找切换到内核态的程序切入点，如果那个切入点存在，就把对应的系统调用的标号存到`a7`寄存器里面(`usys.pl`)，这就将系统调用的信息传递给了内核。	

​	如果需要系统调用的话，需要从用户态切换到内核态。但是用户态的寄存器信息并不是进入内核态还留在那里，所以是先记录了用户态调用系统调用时的参数，以及具体使用了哪一个系统调用。这样在进入内核态以后，`syscall.c`中的`syscall`函数就可以从对应的寄存器信息存储位置中将用户态存储的信息拿出来，以执行相关的系统调用并且得到对应的参数。

​	记录一种以前没见过的数组定义方式，[]里面的是下标。

```c
static char* syscall_name[] = {
[1]    "fork",
[2]    "exit",
[3]    "wait",
[4]    "pipe"
};
```

​	

### 2. Sysinfo

​	仍然是一个系统调用，但是他要去获得当前还没有被使用的内存的信息以及除Unused状态的进程。

​	这就涉及到了内存的管理方式，**这里填个坑**。具体的实现方式就是0x8000....——0x8640...是CPU认为的RAM区域，也就是全部的内存空间，但是这里面还存储了内核自己的代码和数据，因此在此基础上还需要减一部分(代码中的`end`变量)。另外，内存的请求与释放都是以一页（4096KB）为单位的，那么只需要记录每次的申请使用和释放即可得到占用的信息。但要注意初始化的时候的释放是不能被计算在内的。

​	另外，一个文件中的全局变量是不可以用变量来进行初始化的，如

```c
uint64 Used_mem = WHOLE_FREE_MEM - end;
```

​	就会发生报错。
