## A Guidance to Exp2

### 1. Trace

​	系统调用的时候，是从用户态切换到内核态。这个时候需要找切换到内核态的程序切入点，如果那个切入点存在，就把对应的系统调用的标号存到`a7`寄存器里面(`usys.pl`)，这就将系统调用的信息传递给了内核。	

​	如果需要系统调用的话，需要从用户态切换到内核态。但是用户态的寄存器信息并不是进入内核态还留在那里，所以是先记录了用户态调用系统调用时的参数，以及具体使用了哪一个系统调用。这样在进入内核态以后，`syscall.c`中的`syscall`函数就可以从对应的寄存器信息存储位置中将用户态存储的信息拿出来，以执行相关的系统调用并且得到对应的参数。

​	记录一种以前没见过的数组定义方式，[]里面的是下标。

```c
static char* syscall_name[] = {
[1]    "fork",
[2]    "exit",
[3]    "wait",
[4]    "pipe"
};
```

​	

### 2. Sysinfo

​	仍然是一个系统调用，但是他要去获得当前还没有被使用的内存的信息以及除Unused状态的进程。

​	这就涉及到了内存的管理方式：

​	在xv6中，内存（RAM）是硬件，需要用物理地址去访问，共64位。但是事实上只使用了56位，更高位并没有被使用。在这全部的$2^{56}$的地址空间下，也并不是全是RAM，因为还有I/O和磁盘，他们也是占用了一些物理地址的，CPU通过访问这些地址来访问这些外部设备（回忆大二夏季学期做CPU时的外设）。那么属于主存RAM的地址是从 *KERNBASE *$0x800000000$ 开始到 *PHYSTOP* $0x86400000$，这就是CPU可以使用的全部主存，注意这里的地址都是物理地址。那么事实上，在操作系统运行的时候，无论是用户进程还是内核在访问内存的时候，使用的都是虚拟空间，CPU给出的地址也完全是虚拟地址（*virtual address*），是由操作系统，或者是硬件将虚拟地址映射到了物理地址，而实现这个映射的方式，就是使用一个表，称作页表。

​	每一个进程都有一个自己的页表，操作系统的内核也有一个自己的页表。页表的实现方式非常简单，事实上很多的这种存储设备如*cache*,*TLB*(快表)都用了相同的方式去实现。首先定义页(*page*)，一个页的大小为$4096$B，页也是在进行内存划分时的基本单元。

​	页表的工作原理可以非常概括地认为成：

+ 接收到虚拟地址(xv6中的虚拟地址只有39位有效，然而考虑到xv6的主存尚且不到39位，所以理论上一个进程就可以占满RAM，当然操作系统内核已经在RAM的最下端占据了自己的位置)

+ 取虚拟地址的前27位（$27+12=39$,$4096 = 2^{12}$）,用这27位放入页表中索引，页表里的每一条叫做页表项(*Page Table Entry*)，里面存储的是这一页的物理地址（44位 $56=44+12$）以及这一页的信息（标志位）

+ 然后只需要将物理地址和虚拟地址的后12位拼接上即得到某一个单元的物理地址。

  事实上的页表实现稍微复杂一点，因为页表是存放在RAM里面的，按照上面说的，那么一个页表就要存储$2^{27}$那么多个项目，并且每个进程都有一个页表，那么会占据主存里面很大的空间，但大部分的页表其实都是空的，因为一个进程根本用不了那么多的空间。所以在现实情况下，我们将页表**分级**，27位共分成3级，每级有9位，那么一个页表的大小就变成了$2^9=512$项，每一项存的物理地址是下一级的页表的物理地址，这样极大地减少了内存的占用，并且这样做的话一个页表的大小正好就是一个页，便于内存的管理。

  说了这么多，这些其实是LAB3的内容了，不过，仍然要说的是，对于内核，他的虚拟地址和物理地址采取了所谓的*direct-mapping*，也就是说事实上它的虚拟地址在前面加了一堆0以后，就是物理地址了，这样做提供了一些内核操作时的方便。

  具体的实现方式就是0x8000....——0x8640...是CPU认为的RAM区域，也就是全部的内存空间，但是这里面还存储了内核自己的代码和数据，因此在此基础上还需要减一部分(代码中的`end`变量)。另外，内存的请求与释放都是以一页（4096KB）为单位的，那么只需要记录每次的申请使用和释放即可得到占用的信息。但要注意初始化的时候的释放是不能被计算在内的。

​	另外，一个文件中的全局变量是不可以用变量来进行初始化的，如

```c
uint64 Used_mem = WHOLE_FREE_MEM - end;
```

​	就会发生报错。
