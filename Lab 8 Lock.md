# Lab 8 Lock

### 1. Memory allocator

​	思想很简单：

​	为每个CPU都分配一个freelist，这样每个CPU在进行内存的分配或者释放的时候，都只去访问自己的那个freelist。只有当自己的freelist为空的时候再去访问其他CPU的freelist，从其中移一部分出来放入自己的freelist中。

​	具体实现：

 	1.	各个CPU的freelist用一个数组管理。在内核的main()中添加一个kmem_init()的函数，用来初始化各个CPU的freelist。而kinit()中是去初始化第0号CPU的freelist。由于采用了3个CPU，先将所有空闲的页等分到前三个CPU的freelist上，但其实不这样做也没有关系，只是可能会多一点点查看其他CPU的freelist的时间。

	2.	这样在kalloc和kfree的时候都是获取自己的CPU_id然后操作自己的freelist就好了。唯一的不同是，kalloc当自己的freelist为空的时候，要再去访问其他CPU的freelist,如果发现有空闲，则在其freelist上拿10页出来，放到自己的freelist上。（这里我设置了10页，是为了减少这个CPU屡次去查看别的CPU的freelist造成的速度降低）

### 2. Buffer cache

​	思想和过程都类似：

​	初始化每个哈希桶。当磁盘块申请的时候，计算磁盘块的哈希值来找到对应的桶。然后请求对应的桶的锁，进入桶中，如果找到则直接锁住改缓存块并返回。如果没找到，就需要回收一个buffer，先在桶内找，如果桶内没有再去别的桶里面找，把别的桶的buffer拿出来。

​	主要的难点其实在于访问别的桶的时候，怎么避免死锁这个问题。注意这里死锁出现的原因，假如此时已经拿到自己桶（0号桶）的锁的时候，再申请1号桶的锁，而恰巧有另一个CPU已经拿到了1号桶的CPU，在申请0号桶的锁，这就产生了死锁。解决的方式是在已经拿到了自己桶的锁的时候，查看别的桶的时候不是从0开始一直找到NBUCKETS-1，而是从当前桶的下一个开始，这样做其实相当于是顺序的请求了锁，但是理论上，其实真的还有可能出现上述的情况，但这时是整个缓冲区都没有空闲的块了，在未经修改的代码中其实也是panic了，都是出现问题的，这种情况也基本不会出现，所以可以不考虑。