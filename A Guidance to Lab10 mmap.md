# A Guidance to Lab10 mmap

 最后一篇guidance了，多少有点感慨，MIT的xv6虽然有一点点折磨，但是感觉还是很长知识很提高动手能力的。

言归正传，mmap是指将一个文件的一部分映射到现在这个用户进程的内存某个位置，可以控制映射多少页，是否可读可写，写完了以后要不要再写回到文件等等。可以看出来这个还是比较复杂的一个事，这里实现的是一个无限阉割版，本来实验要求的就已经简单一些了，如果看一下测试用例，就更简单了。但是还是踩了几个坑。

需要实现的是mmap和munmap。

首先，mmap的系统调用是lazy的，类似lazy allocation的办法，就是mmap说要映射一个文件，好，我就只根据你的文件的大小，增大我这个进程的sz，但是实际上，我的页表上的对应的位置还没有对应的物理页，直到用户进程真的要访问的时候，这个时候由于页表上还没有，就会usertrap进入内核，然后判断一下是不是因为mmap的lazy allocation导致的，如果不是，那是真的usertrap，直接杀死进程就好了；可如果是，这个时候就要真的把文件map到对应的页表上，然后再返回。接着是munmap，这里实现起来似乎考虑的不那么周全，就是根据munmap的输入，如果对应的地方之前usertrap进来了，分配了物理页，那么我就给释放掉，如果没有，就不需要管，然后进程的sz也不需要改。。因为可能这个mmap是中间的一个部分。然后如果mmap的时候是MAP_SHARED的话，也需要把内容给写回到文件中，这里也不用管到底改没改，直接往回写就行了（如果文件超级大，性能可能会有问题）。还有两个函数要改，一个是exit，进程结束的时候，mmap的地方要么写回，要么直接释放掉。还有是fork，这里实现的也是not cool的版本，父进程和子进程不用同一个mmap的物理页，父进程拷贝进程的时候直接把自己哪一段内存是mmap对应的“告诉”子进程，也不用管这一段内存到底是不是经过usertrap进入了内核然后分配的，反正子进程先不分配这些内存。需要的时候再进入子进程的usertrap分配。最后，由于是lazy allocation，所以还要改一下一些uvm的函数，uvmunmap的时候，如果发现有一页并没有实际被map，那么也不panic，继续往下走；uvmcopy的时候（用在fork的时候），uvmcopy是一页一页进行map的，将其每一页分配一个物理块，然后放到子进程的页表上。但是，在父进程拷贝的时候，如果这一页是父进程的mmap页，那么直接跳过，不需要拷贝。

这是大概的流程，还有一些细节，比如，上面的“告诉”到底是怎么做到的。

+ 定义父VMA和子VMA数组（VMA: virtual memory area)

  + 父VMA数组

    每当用户进程调用了mmap的时候，需要把到底用户需要映射哪一个文件，文件的开始（offset)，映射多长，映射的访问权限（读、写），映射模式记录下来，注意这里的一个坑，存储到底是哪一个文件的时候，存储的是文件的指针struct file*，而不能存一个文件描述符fd，因为可能用户在把这个文件映射到内存了以后，把文件关掉了，那样的话会同时把进程里面ofile[fd]对应的文件指针清空，这样就找不到这个文件了。这是所谓的父VMA，记录的是这个进程中应该是mmap映射的部分，但并不一定真的映射了。同时还有一个细节，我觉得是这个试验中我考虑最多的，就是地址的页对齐，在mmap的用户调用的时候，我都是把sz先取到PGROUNDUP，然后再加length，作为新的进程的sz，存储在VMA的时候mmap的开始地址也是存储的这个PGROUNDUP得到的地址。父VMA数组还有一个字段，稍后会提。

  + 子VMA数组
  
    子VMA数组是用来存真正被mmap的那些内存地址，也就是说，他是在usertrap的时候，为缺失的页补充的时候，记录下来的，它的长度都是一页。usertrap的时候，在父VMA数组中寻找，查看这个unmapped_va是不是在某个父VMA的地址中，如果是的话，分配一个物理页，用readi把文件读进去，父VMA的actually_mapped加一，然后如果这是这个mmap第一次usertrap的话，需要加一个file的refcnt，让这个文件在用户态被关了的时候，不会被写回去。同时，加一个子VMA记录这个被映射的一页，同时子VMA要记录父亲VMA节点在数组中的位置，因为当munmap的时候，要把父VMA的actually_mapped减一，如果见到了0，要给这个文件的refcnt--，表示这个文件已经完全从上次的mmap上被取下来了。这一页被unmmaped了以后，这个子VMA数组项就没用了。注意，munmap的时候就是查找子VMA数组项，如果没查到，说明这一页根本就没被usertrap进来被分配，就不用管了。

​			