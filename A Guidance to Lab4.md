## A Guidance to Lab4

### 2. Backtrace

需要明白的是，一个栈是由多个frame构成的，这个frame存的是当前函数的一些局部变量，这个frame结束以后的返回地址，让这个frame产生的caller的frame的指针，暂存的寄存器内容等值。`sp`指向的是栈顶，而`fp`指向的是这个frame的最高地址(栈底)。

那么这个过程就比较简单了，由于一个进程在内核中的内核栈只有一页，所以从当前frame开始，根据每一个frame自己存储的返回地址以及caller frame的指针，先把返回地址打印，然后回到上一个frame，重复操作。检查是否到头的方法就是检查是否已经到达了栈底(最高地址)

### 3.Alarm

这个虽然是hard，但是其实没有很难（好吧我也写了一个下午，但是不是在调试）。设置了两个系统调用，第一个`sigalarm`是一个设置，设置时间片和跳转的函数handler，第二个是`sigreturn`，因为这个跳转是从系统发出的，所以要`sigreturn`把用户态的执行状态转移回被系统中断的地方。

具体的实现其实是利用了xv6本身的时间片的设置，每到一个`ticks`，时间片自动发出中断，系统从用户态回到内核，并且是可以检测到是时间片发出的中断，那么就调用`yield`进行进程的切换，达到并发的效果。

那么这个`sigalarm`就比较简单，调用的时候检查是否有效，即第一个参数不等于0的时候是有效的。然后在这个进程自己内部存一个记录的值，每当是从这个函数的时间片到期回到内核的时候，这个记录值减1，如果这个记录值减到了0，那么这个时候就应该返回到用户态的时候返回到`handler`的位置，所以要把`trapframe`中的`epc`切换到`handler`所在的位置。并且，`handler`执行过程中如果时间片到期进入内核，还要继续去执行`hanlder`,不应该去计时更改进程自己的记录值。那么`handler`执行完了以后，要重新回到正常的用户态的执行位置，并且这个过程对于用户的原来的程序是透明的，也就是说他是感觉不到的。然而我们在刚才的操作里面只是简单的修改了`epc`,即跳转的位置，在`handler`中可能对寄存器各种修改，并且由于`handler`是在函数的最后调用了`sigreturn`，进入内核态以后不会再回到`handler`了，尽管从C语言的角度看这并不影响，但是如果看汇编会发现，在跳转到`sigreturn`之后，执行结束的时候会重新修改栈指针、返回值等位置，这样，寄存器`sp,ra`等都被修改。

因此，我们需要在每次这个进程的正常的用户态程序的时间片到期，并且用完了记录值的时候，把这个时候这个进程的所有寄存器的状态存起来即`trapframe`当中，当`handler`执行完了以后再把这个存起来的`trapframe`扣到要返回的`trapframe`的位置上，就可以保证原来的用户态进程不会被影响。(然而事实上，经过实验，只需要保存ra,sp,s0,a1,epc即可足够通过test。其实这与观察的汇编的过程并不相同，因为handler事实上并没有去修改a1，不知道为什么必须要存a1)

