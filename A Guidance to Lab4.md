## A Guidance to Lab4

### 2. Backtrace

需要明白的是，一个栈是由多个frame构成的，这个frame存的是当前函数的一些局部变量，这个frame结束以后的返回地址，让这个frame产生的caller的frame的指针，暂存的寄存器内容等值。`sp`指向的是栈顶，而`fp`指向的是这个frame的最高地址(栈底)。

那么这个过程就比较简单了，由于一个进程在内核中的内核栈只有一页，所以从当前frame开始，根据每一个frame自己存储的返回地址以及caller frame的指针，先把返回地址打印，然后回到上一个frame，重复操作。检查是否到头的方法就是检查是否已经到达了栈底(最高地址)

### 3.Alarm

这个虽然是hard，但是其实没有很难（好吧我也写了一个下午，但是不是在调试）。设置了两个系统调用，第一个`sigalarm`是一个设置，设置时间片和跳转的函数handler，第二个是`sigreturn`，因为这个跳转是从系统发出的，所以要`sigreturn`把用户态的执行状态转移回被系统中断的地方。

具体的实现其实是利用了xv6本身的时间片的设置，每到一个`ticks`，时间片自动发出中断，系统从用户态回到内核，并且是可以检测到是时间片发出的中断，那么就调用`yield`进行进程的切换，达到并发的效果。

那么这个`sigalarm`就比较简单，调用的时候检查是否有效，即第一个参数不等于0的时候是有效的。然后在这个进程自己内部要做一个记录，记录`sigalarm`传递过来的两个参数，一个对应的是要在第几个时间片切换到handler，一个是handler的地址，这个地址是一个用户态的程序段的地址。同时还要加一个`remain_tick`，来记录已经过了几个时间片了。

每当是从这个函数的时间片到期回到内核的时候，这个记录值减1，如果这个记录值减到了0，那么这个时候就应该返回到用户态的时候返回到`handler`的位置，所以要把`trapframe`中的`epc`切换到`handler`所在的位置。并且，`handler`执行过程中如果时间片到期进入内核，还要继续去执行`hanlder`,不应该去计时更改进程自己的记录值。那么`handler`执行完了以后，要重新回到正常的用户态的执行位置，并且这个过程对于用户的原来的程序是透明的。然而我们在刚才的操作里面只是简单的修改了`epc`,即跳转的位置，在`handler`中可能对寄存器有各种修改，并且由于`handler`是在函数的最后调用了`sigreturn`，进入内核态以后不会再回到`handler`了，尽管从C语言的角度看这并不影响，但是如果看汇编会发现，在跳转到`sigreturn`之后，执行结束的时候会重新修改栈指针、返回值等位置，这样，寄存器`sp,ra`等都被修改。

因此，我们需要在每次这个进程的正常的用户态程序的时间片到期，并且用完了记录值的时候，把这个时候这个进程的所有寄存器的状态存起来即`trapframe`当中，当`handler`执行完了以后调用`sigreturn`的时候再把这个存起来的`trapframe`原原本本的恢复，然后就可以直接回到当时时间片到期进入内核时的状态，当时的CPU“现场”被保存在了xv6的PCB中(`struct proc`)，这里我是将整个trapframe的所有寄存器全部保存下来了，这样就可以保证原来的用户态进程不会被影响。（因为既然从用户态进入内核的时候没保存了trapframe内的寄存器就不会对用户态的程序有任何影响，那么我只要保存trapframe内的寄存器就可以了）

主要的代码其实都是在kernel/trap.c中，就是判断是不是因为时间片到期进入内核、如果是，是不是一个设置了sigalarm的进程、如果还是，`remain_tick--`、如果减到了0，那就保存现场，跳转到handler去执行。
