## Lab3 Guidance —— PageTable

```
Lab3我一共用了基本上四天，完全看xv6的书就用了一天半，再加上早八到晚十一的调试代码的后面的两天半，还是比较有挫败感的。
不做一下MIT的实验，真的不知道自己有多菜。
```

言归正传，Lab3主要是处理PageTable——页表。页表的有关内容已经在Lab2 Guidance里面讲的比较细致了。再稍微补充两个点：

1. 对于内核来说，内核的页表由于是direct-mappping，所以内核中用的地址其实就是物理内存的实际地址。0x8000...以下的是设置硬件的中断有关，0x8000...以上到0x8640...是物理内存，再很上面的位置是每个进程的内核栈（注意，xv6中，最多只可以同时有64个进程，这些进程是在一开始就被初始化好的，他们的信息一直是存起来的，当遇到`fork()`这样的函数的时候，就在这64个里面选一个没有被使用的，然后把他们的内核栈和进程在内核中存储的相关信息(`PCB`)初始化为应该的样子，然后这个进程就可以被使用了。
2. 而对于用户来说，用于虚拟地址的机制，用户的地址空间是一段连续的，从0开始依次放，具体的对应的物理地址是按照页的大小，一页一页存储在物理内存中的，每一页的开始的物理地址也存放在这个进程的页表里面。

### Exp1.Print a page table

这个比较简单，是在第一个进程执行的时候打印出这个进程当前的页表中有意义的项。对应的函数`vmprint(pagetable)`是放在了`vm.c`文件中，实现方式还是非常直接的。

原理：页表在初始化的时候全置为0。如果页表的某一个`PTE`有意义，那么这个`PTE`的对应的最后一位，也就是`PTE_V`这一位就是1。通过这个来检查这下面有没有页表或者对应的物理内存。

实现步骤：这个也很直接，递归，传递一个level表示是第几层的页表，如果是最后一层了，就不要再往下走了，已经是物理地址了。程序本身也比较简单，就是512个页表项依次往下走，如果下面还存了页表就递归，没存就下一个页表项。

### Exp2. A kernel page table per process

这个其实我实现的也比较快，只要想好了怎么做，一步一步来就好了。

这里说的是要为每个进程自己加一个内核态的页表，正常情况下，一个进程在进入内核态了以后，就自动切换成了内核态的页表。但这里为每一个进程加了内核态的页表以后，这个进程在进入内核态的时候的页表就要变成他自己的内核态的页表，那么这个页表至少要有原来内核态的页表有的东西，也就是那些0x8000...以下的**硬件的映射**以及**RAM的映射**，还有**这个进程自己的内核栈的映射**，别的进程的内核栈可以不管，再加上最顶层的trampolined那两页。

实现的过程也比较简单，按hint一条一条来就好。

+ 在proc这个结构体加上一个存ppk_pagetable (ppk:per process kernel)的位置
+ 然后，根据内核页表的初始化过程如法炮制，初始化这个进程的内核页表，然后根据这个进程结构体中的内核栈的地址，将其映射到内核页表上。
+ 然后，在scheduler中，进程切换到内核态的时候把当前的进程的内核页表装载进寄存器，进程结束返回的时候，再重新用内核自己的内核页表。
+ 最后，在一个进程结束的时候，要把他占用的空间全部free掉，但是注意在free用户页表的时候，是先把物理地址都free了，再去free页表的位置，但是内核页表就不行，它对应的物理地址不是他自己的地址，只可以去free页表（函数改自freewalk,就是去掉了对物理内存的检查那个部分。

就结束了，这个实验通过的非常happy，然而，第三个实验，才刚刚开始.....

### Exp3.Simplify `copyin/copyinstr`

这个的想法其实也很自然，你既然都把内核页表换成进程自己的了，总得干点啥。那么一般用户态进入内核态的时候，会通过寄存器存几个参数，有的就是一个数字，有的却是一个用户地址空间的地址，这个时候内核需要从对应的物理地址里面去把数据拿出来，这个时候就需要用到`copyin`和`copyinstr`函数，他的实现方法也就是利用进程控制块存放的用户态页表地址，去找对应的物理地址，然后把数据拿出来。

那么，既然现在的页表是进程自己的，我们不妨就把用户态的物理地址映射进内核页表，虚拟地址还保持和用户态一样，又由于内核用的是比较高的地址0x8000...，即使是那些低于0x8000...的硬件地址也比较高，在系统boot了以后，从0到0xc000000（`PLIC`）都是可以用的。

那么，我们要做的，就是把用户的地址全部映射到内核页表上，并且要在用户的地址空间改变的时候，也要把内核页表一起改变，具体在三个函数上`fork()`,`sbrk()`,`exec()`。

具体的思路其实是比较简单的，就是每当这三个函数把用户的地址空间改变的时候，同时也去改变内核页表的映射，可以统一用一个函数来做`user_mapto_kernel`但就是这个过程有一些小的细节需要注意，并且三个函数的处理思路也不一样。

+ `fork`最简单，是一个进程从无到有的过程，所以是从他的虚拟地址0到这个进程的全部大小全部都映射在内核页表上面。
+ `sbrk`是给一个进程增或者减用户空间，这个也不难。如果是增，就从以往的size的地址一页一页添加映射，加到内核页表上。如果是减，那就`uvmunmap`
+ `exec`的原始代码我看的比较懵，所以就采用了最笨的方式，先根据变化之前的进程大小，把内核页表里面全部的用户态的空间全部`uvmunmap`掉，然后再一页一页读进程的用户态页表，把每一个对应的物理地址映射到内核态的页表上。

事实上，我一开始三种函数都用的是那种最笨的方法，但后来发现在`usertests`里面会有很多的频繁改变用户态地址空间的操作，这就会非常慢，甚至导致`timeout`，所以不得不按照实际情况修改了一下。

还有两个细节，是我一开始没有注意的，所以导致了很多问题：

+ 首先，在从用户页表读出来物理地址，然后再将其映射到内核页表上的时候，需要一页一页的去把物理地址读出来，然后再映射。不能把起始的虚拟地址对应的物理空间读出来，然后直接一共多少页全用`mappages`。现在看来显然不对，每一页的物理地址对应的不一样,直接这样整显然往内核上映射的物理地址是不对的（当然，如果是只整一页，是对的）
+ 其次，输入这个函数的size一定是page-aligned的，也就是一定要用一个宏`PGROUNDUP`，把它上面的那个页的地址得到，因为循环是从0开始的，同时也用的是小于号。

另外，还有两个有一点点问题的，我不知道这样做对不对

+ 首先，把`remap`的panic给取消掉
+ 其次，把`kerneltrap`的panic给取消掉

**上面的两个panic似乎是解决了。原因竟然是：fork我是在release了子进程的锁之后再去映射的？？？**

反正这样`usertests`是过了。

噢对，还有，`CLINT`不需要映射到进程的内核页表上，只要boot了以后就没用了，所以就不需要了。

另外`map_check`也不能用，至少不能panic，因为他总是会停在panic上，但其实不panic也没用。
