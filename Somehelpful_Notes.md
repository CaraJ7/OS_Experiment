## 一些C语言或者操作系统有用的事情

### 1. 关于指针和数组

   数组的名字：该数组第一个元素的地址。

   比如：`int p[5]` p为第一个元素的地址，即p为一个int型变量的地址，p为int*

   ​			`int p[5][4]` p为第一个元素的地址，第一个元素是一个整数数组，而一个整数数组是int*，那么p理论上为int**（实际并不是，见下面）

   然而，事实并没有那么简单。对于`int p[5][4]`，这里的p并不是一个int**，如果有一个函数需要int\*\*，那么传入p的时候会报错，报错的原因是p事实上是一个int(\*)[4]。那么怎么办呢，如果就是需要一个int\*\*的数组，里面还有元素。这个时候只能动态申请，先申请5个int\*的空间来放各个数组的头指针，再对于每个数组单独申请空间。

```c
int** p;
p = (int**)malloc(5*sizeof(int*));//p是int**，也就是int*的地址
for(int i=0;i<5;i++){
    p[i]=(int*)malloc(4*sizeof(int));
    //p[i]就是*(p+i),也就是第i个int*的地址再取址，那么也就是第i个int*
}
```

经过一些查阅，逐渐理清了几个概念：

+ 对于二维数组，虽然理论上应该是int\*\*，但实际上是int(\*)[N]。

  应该可以想起，在定义的时候就需要高维数组的从右往左，除了最高维度都需要被给出。这是因为在放置内存的时候需要告诉这个数组的名字到底一行是几个。那么**其实数组的名字就是一个存有行数信息的`int*`**，使得其在进行`p[2][3]`的操作的时候，知道应该拿的是`*(p+2*N+3)`，也就是说，**二维数组的名字其实是一个特殊一点的`int*`。**并不是像你想的那样，又单独拿出来一些空间去存`int*`，这些`int*`是每个一维数组的头指针，这多少有一点浪费。

  那么，将一个二维数组的名字强制转化成一个`int**`也就是不对的了，编译器会把原来的值改变，得到一个无意义的值。

  可以验证的程序是：

  （**二维数组仍然指向数组的第一个元素，只不过每次$+1$的时候偏移量是一维数组的长度**）

  ```c
  int n[3][4]={{1,3,4,5},{2,6,7,8}};
  printf("first is %p\nsecond is %p\n",n,n[0]);
  // 输出的两个值是一样的

+ 对于`char* p[]={"hello","there"};`，字符串常量有一个自己的地址，那么实际上是把这两个字符串常量的地址存进了p[0]和p[1]。这个时候的p确实是一个`char**`,可以理解为定义了一个`char*`类型的数组，并且通过赋初值使其不需要指定长度(如`int p[]={2,3,4};`)。

  然而，由于是字符串常量，那么其实其中的元素不能被改变，尝试：

  ```c
  p[0][1]='1';
  ```

  会给出段错误。
  
  再看下面的程序
  
  ```c
      int* m[]={{2,3,4},{1,7,8,6}};//错误，常数数组不知道怎么用指针表示
      char* d[]={"hello","q","pooo"};//正确，字符串常量就是用一个指针表示
      int r[]={3,4,5};//正确，直接把3,4,5放到内存中
  ```
  
  

**总结一下**，那么，如果真的需要一个`char**`的字符串数组（如exec函数中的第二个参数）,那么还是老老实实动态分配一个`char*`的数组，再对其中的每一个元素分配空间吧。

### 2.exec函数

​	考虑，为什么bash需要子进程去执行，父进程直接执行不行吗？

​	不可以!`exec`函数的特点是：除非出错，否则永远不返回，进程在`exec`中被终止掉，如果只有一个父进程，bash执行完这个命令以后就结束了。